local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- üèπ H√†m t√¨m ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t
local function getNearestPlayer()
    local closestPlayer = nil
    local closestDistance = math.huge  -- Gi√° tr·ªã v√¥ h·∫°n ƒë·ªÉ so s√°nh

    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("Head") then
            local head = otherPlayer.Character.Head
            local distance = (head.Position - camera.CFrame.Position).Magnitude
            
            if distance < closestDistance then
                closestDistance = distance
                closestPlayer = otherPlayer
            end
        end
    end

    return closestPlayer
end

-- üîÑ C·∫≠p nh·∫≠t Camera theo ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t
local function updateCamera()
    local targetPlayer = getNearestPlayer()
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
        local head = targetPlayer.Character.Head
        camera.CameraSubject = head
        camera.CFrame = CFrame.new(camera.CFrame.Position, head.Position)
    end
end

-- üöÄ Khi v√†o game, ghim v√†o ng∆∞·ªùi g·∫ßn nh·∫•t
task.wait(1)  -- ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ m·ªçi ng∆∞·ªùi load v√†o game
updateCamera()

-- üéØ Li√™n t·ª•c c·∫≠p nh·∫≠t Camera
RunService.RenderStepped:Connect(updateCamera)

-- ‚ò†Ô∏è Khi ng∆∞·ªùi ch∆°i ch·∫øt, t·ª± ƒë·ªông ƒë·ªïi m·ª•c ti√™u
player.CharacterRemoving:Connect(function()
    task.wait(0.5)  -- ƒê·ª£i nh√¢n v·∫≠t ch·∫øt h·∫≥n
    updateCamera()  -- Ghim v√†o ng∆∞·ªùi g·∫ßn nh·∫•t
end)
